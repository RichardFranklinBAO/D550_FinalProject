knitr::opts_chunk$set(echo = TRUE)
library(dplyr);
library(tidyr);
library(purrr)
library(ggplot2);
library(PerformanceAnalytics);
library(slider);
library(readr);
library(xts);
here::i_am("R_Project.Rmd")
prices <- read.csv(here::here('data', 'raw', 'all_stocks_5yr.csv'), stringsAsFactors = FALSE)
# last close per month -> log returns
rets <- prices |>
mutate(month = as.Date(cut(date, "month"))) |>
group_by(Name, month) |>
summarise(close = dplyr::last(close), .groups = "drop") |>
arrange(Name, month) |>
group_by(Name) |>
mutate(ret = log(close / lag(close))) |>
ungroup() |>
filter(!is.na(ret))
prices <- prices |>
mutate(date = as.Date(date))
# last close per month -> log returns
rets <- prices |>
mutate(month = as.Date(cut(date, "month"))) |>
group_by(Name, month) |>
summarise(close = dplyr::last(close), .groups = "drop") |>
arrange(Name, month) |>
group_by(Name) |>
mutate(ret = log(close / lag(close))) |>
ungroup() |>
filter(!is.na(ret))
# store a cleaned copy (optional)
dir.create("data/clean", recursive = TRUE, showWarnings = FALSE)
write_csv(rets, here::here('data', 'clean', 'monthly_returns.csv'))
# 12–1 momentum = sum of monthly log returns over [t-12, t-2], skipping t-1
mom_tbl <- rets |>
arrange(Name, month) |>
group_by(Name) |>
mutate(
ret1m   = ret,
roll12  = slide_dbl(ret1m, ~ sum(.x), .before = 11, .complete = TRUE),
mom_12_1 = dplyr::lag(roll12, 1)
) |>
ungroup() |>
tidyr::drop_na(mom_12_1)
# each month: deciles by momentum; long Q10, short Q1
port_tbl <- mom_tbl |>
group_by(month) |>
mutate(ntile = ntile(mom_12_1, 10)) |>
summarise(
long  = mean(ret1m[ntile == 10], na.rm = TRUE),
short = mean(ret1m[ntile == 1 ], na.rm = TRUE),
ls    = long - short,
.groups = "drop"
)
# simple transaction-cost adjustment
cost_rate <- 0.0003  # 3 bps per side
turnover  <- 0.5     # monthly turnover assumption
port_tbl  <- port_tbl |>
mutate(ls_net = ls - 2 * cost_rate * turnover)
# sample coverage + performance metrics
R_ls <- xts::xts(port_tbl$ls, order.by = port_tbl$month)
tab1 <- tibble::tibble(
start      = min(port_tbl$month),
end        = max(port_tbl$month),
n_stocks   = length(unique(rets$Name)),
n_obs      = nrow(rets),
mean_LS    = mean(port_tbl$ls, na.rm = TRUE),
ann_ret    = as.numeric(PerformanceAnalytics::Return.annualized(R_ls, scale = 12)),
ann_vol    = as.numeric(PerformanceAnalytics::StdDev.annualized(R_ls, scale = 12)),
sharpe     = as.numeric(PerformanceAnalytics::SharpeRatio.annualized(R_ls, scale = 12))
)
knitr::kable(tab1, digits = 4, caption = "Sample coverage and momentum long–short performance (gross).")
cum_df <- port_tbl |>
mutate(cum = exp(cumsum(ls)),
cum_net = exp(cumsum(ls_net))) |>
select(month, cum, cum_net) |>
pivot_longer(-month, names_to = "series", values_to = "value")
ggplot(cum_df, aes(month, value, linetype = series)) +
geom_line(linewidth = 0.8) +
scale_linetype_manual(values = c("solid","dashed"), labels = c("Gross","Net of costs")) +
labs(title = "Cross-Sectional Momentum (12–1): Cumulative Return",
x = NULL, y = "Growth of $1", linetype = NULL) +
theme_minimal(base_size = 12)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr);
library(tidyr);
library(purrr)
library(ggplot2);
library(PerformanceAnalytics);
library(slider);
library(readr);
library(xts);
here::i_am("R_Project.Rmd")
prices <- read.csv(here::here('data', 'raw', 'all_stocks_5yr.csv'), stringsAsFactors = FALSE)
prices$date <- as.Date(prices$date)
prices <- prices |>
mutate(date = as.Date(date))
# last close per month -> log returns
rets <- prices |>
mutate(month = as.Date(cut(date, "month"))) |>
group_by(Name, month) |>
summarise(close = dplyr::last(close), .groups = "drop") |>
arrange(Name, month) |>
group_by(Name) |>
mutate(ret = log(close / lag(close))) |>
ungroup() |>
filter(!is.na(ret))
# store a cleaned copy (optional)
dir.create("data/clean", recursive = TRUE, showWarnings = FALSE)
write_csv(rets, here::here('data', 'clean', 'monthly_returns.csv'))
# 12–1 momentum = sum of monthly log returns over [t-12, t-2], skipping t-1
mom_tbl <- rets |>
arrange(Name, month) |>
group_by(Name) |>
mutate(
ret1m   = ret,
roll12  = slide_dbl(ret1m, ~ sum(.x), .before = 11, .complete = TRUE),
mom_12_1 = dplyr::lag(roll12, 1)
) |>
ungroup() |>
tidyr::drop_na(mom_12_1)
# each month: deciles by momentum; long Q10, short Q1
port_tbl <- mom_tbl |>
group_by(month) |>
mutate(ntile = ntile(mom_12_1, 10)) |>
summarise(
long  = mean(ret1m[ntile == 10], na.rm = TRUE),
short = mean(ret1m[ntile == 1 ], na.rm = TRUE),
ls    = long - short,
.groups = "drop"
)
# simple transaction-cost adjustment
cost_rate <- 0.0003  # 3 bps per side
turnover  <- 0.5     # monthly turnover assumption
port_tbl  <- port_tbl |>
mutate(ls_net = ls - 2 * cost_rate * turnover)
# sample coverage + performance metrics
R_ls <- xts::xts(port_tbl$ls, order.by = port_tbl$month)
tab1 <- tibble::tibble(
start      = min(port_tbl$month),
end        = max(port_tbl$month),
n_stocks   = length(unique(rets$Name)),
n_obs      = nrow(rets),
mean_LS    = mean(port_tbl$ls, na.rm = TRUE),
ann_ret    = as.numeric(PerformanceAnalytics::Return.annualized(R_ls, scale = 12)),
ann_vol    = as.numeric(PerformanceAnalytics::StdDev.annualized(R_ls, scale = 12)),
sharpe     = as.numeric(PerformanceAnalytics::SharpeRatio.annualized(R_ls, scale = 12))
)
knitr::kable(tab1, digits = 4, caption = "Sample coverage and momentum long–short performance (gross).")
cum_df <- port_tbl |>
mutate(cum = exp(cumsum(ls)),
cum_net = exp(cumsum(ls_net))) |>
select(month, cum, cum_net) |>
pivot_longer(-month, names_to = "series", values_to = "value")
ggplot(cum_df, aes(month, value, linetype = series)) +
geom_line(linewidth = 0.8) +
scale_linetype_manual(values = c("solid","dashed"), labels = c("Gross","Net of costs")) +
labs(title = "Cross-Sectional Momentum (12–1): Cumulative Return",
x = NULL, y = "Growth of $1", linetype = NULL) +
theme_minimal(base_size = 12)
knitr::opts_chunk$set(echo = FALSE)
library(dplyr);
library(tidyr);
library(purrr)
library(ggplot2);
library(PerformanceAnalytics);
library(slider);
library(readr);
library(xts);
here::i_am("R_Project.Rmd")
# 4: Results — table
# sample coverage + performance metrics
R_ls <- xts::xts(port_tbl$ls, order.by = port_tbl$month)
tab1 <- tibble::tibble(
start      = min(port_tbl$month),
end        = max(port_tbl$month),
n_stocks   = length(unique(rets$Name)),
n_obs      = nrow(rets),
mean_LS    = mean(port_tbl$ls, na.rm = TRUE),
ann_ret    = as.numeric(PerformanceAnalytics::Return.annualized(R_ls, scale = 12)),
ann_vol    = as.numeric(PerformanceAnalytics::StdDev.annualized(R_ls, scale = 12)),
sharpe     = as.numeric(PerformanceAnalytics::SharpeRatio.annualized(R_ls, scale = 12))
)
tab1_fmt <- tab1 |>
dplyr::transmute(
`Sample start`                   = format(start, "%Y-%m"),
`Sample end`                     = format(end, "%Y-%m"),
`Unique tickers`                 = comma(n_stocks),
`Stock–month observations`       = comma(n_obs),
`Avg monthly long–short (log)`   = percent(mean_LS, accuracy = 0.01),
`Annualized return`              = percent(ann_ret, accuracy = 0.01),
`Annualized volatility`          = percent(ann_vol, accuracy = 0.01),
`Sharpe ratio`                   = round(sharpe, 2)
)
# 4: Results — table
# sample coverage + performance metrics
R_ls <- xts::xts(port_tbl$ls, order.by = port_tbl$month)
tab1 <- tibble::tibble(
start      = min(port_tbl$month),
end        = max(port_tbl$month),
n_stocks   = length(unique(rets$Name)),
n_obs      = nrow(rets),
mean_LS    = mean(port_tbl$ls, na.rm = TRUE),
ann_ret    = as.numeric(PerformanceAnalytics::Return.annualized(R_ls, scale = 12)),
ann_vol    = as.numeric(PerformanceAnalytics::StdDev.annualized(R_ls, scale = 12)),
sharpe     = as.numeric(PerformanceAnalytics::SharpeRatio.annualized(R_ls, scale = 12))
)
tab1_fmt <- tab1 |>
dplyr::transmute(
`Sample start`                   = format(start, "%Y-%m"),
`Sample end`                     = format(end, "%Y-%m"),
`Unique tickers`                 = comma(n_stocks),
`Stock–month observations`       = comma(n_obs),
`Avg monthly long–short (log)`   = percent(mean_LS, accuracy = 0.01),
`Annualized return`              = percent(ann_ret, accuracy = 0.01),
`Annualized volatility`          = percent(ann_vol, accuracy = 0.01),
`Sharpe ratio`                   = round(sharpe, 2)
)
# 4: Results — table
# sample coverage + performance metrics
R_ls <- xts::xts(port_tbl$ls, order.by = port_tbl$month)
library(scales)
# 原始汇总（保持不变）
tab1 <- tibble::tibble(
start      = min(port_tbl$month),
end        = max(port_tbl$month),
n_stocks   = dplyr::n_distinct(rets$Name),
n_obs      = nrow(rets),
mean_LS    = mean(port_tbl$ls, na.rm = TRUE),
ann_ret    = as.numeric(PerformanceAnalytics::Return.annualized(R_ls, scale = 12)),
ann_vol    = as.numeric(PerformanceAnalytics::StdDev.annualized(R_ls, scale = 12)),
sharpe     = as.numeric(PerformanceAnalytics::SharpeRatio.annualized(R_ls, scale = 12))
)
# 格式化 + 完整列名
tab1_fmt <- tab1 |>
dplyr::transmute(
`Sample start`                   = format(start, "%Y-%m"),
`Sample end`                     = format(end, "%Y-%m"),
`Unique tickers`                 = comma(n_stocks),
`Stock–month observations`       = comma(n_obs),
`Avg monthly long–short (log)`   = percent(mean_LS, accuracy = 0.01),
`Annualized return`              = percent(ann_ret, accuracy = 0.01),
`Annualized volatility`          = percent(ann_vol, accuracy = 0.01),
`Sharpe ratio`                   = round(sharpe, 2)
)
knitr::kable(
tab1_fmt,
caption = "Sample coverage and momentum long–short performance (gross).",
align   = c("l","l","r","r","r","r","r","r")
)
library(readr)
library(dplyr)
library(stringr)
here::i_am("R_version/Selecting_single_dataset.Rmd")
df <- read_csv(here::here('Data', 'Raw', 'nuMoM2b_Merged_Dataset.csv'),
show_col_types = FALSE)
library(readr)
library(dplyr)
library(stringr)
here::i_am("R_version/Selecting_single_dataset.Rmd")
save_path <- here::here('R_version', 'Selecting_single_dataset.Rmd', 'outputs')
items <- list(
c(3,  "a04"),
c(5,  "a09"),
c(25, "cla"),
c(27, "cma"),
c(28, "cmb"),
c(30, "cmd"),
c(31, "cme"),
c(35, "demographics"),
c(41, "pregnancy_outcomes"),
c(42, "s01"),
c(43, "s02"),
c(57, "v1a"),
c(58, "v1b"),
c(59, "v1c"),
c(60, "v1e"),
c(61, "v1f"),
c(65, "v1l"),
c(66, "v2a"),
c(70, "v3a"),
c(71, "v3b"),
c(72, "v3c"),
c(77, "v3l"),
c(78, "v4a"),
c(79, "vxx")
)
save_path <- here::here('R_version', 'outputs')
if (!dir.exists(save_path)) dir.create(save_path, recursive = TRUE)
datasets <- list()
for (i in seq_along(items)) {
num <- as.integer(items[[i]][1])
prefix <- items[[i]][2]
cols <- names(df)[str_starts(names(df), prefix)]
pick <- c(if ("PublicID" %in% names(df)) "PublicID" else NULL,
setdiff(cols, "PublicID"))
single_df <- df %>% select(all_of(pick))
name <- sprintf("%d_%d_%s_single_dataset", i, num, prefix)
write_csv(single_df, file.path(save_path, paste0(name, ".csv")))
}
# 使用：
# datasets[["1_5_a09_single_dataset"]] %>% glimpse()
library(readr)
library(dplyr)
library(stringr)
here::i_am("R_version/Selecting_single_dataset.Rmd")
df <- read_csv(here::here('Data', 'Raw', 'nuMoM2b_Merged_Dataset.csv'),
show_col_types = FALSE)
items <- list(
c(3,  "a04"),
c(5,  "a09"),
c(25, "cla"),
c(27, "cma"),
c(28, "cmb"),
c(30, "cmd"),
c(31, "cme"),
c(35, "demographics"),
c(41, "pregnancy_outcomes"),
c(42, "s01"),
c(43, "s02"),
c(57, "v1a"),
c(58, "v1b"),
c(59, "v1c"),
c(60, "v1e"),
c(61, "v1f"),
c(65, "v1l"),
c(66, "v2a"),
c(70, "v3a"),
c(71, "v3b"),
c(72, "v3c"),
c(77, "v3l"),
c(78, "v4a"),
c(79, "vxx")
)
items_upper <- lapply(items, function(x) c(x[1], toupper(x[2])))
save_path <- here::here('R_version', 'outputs')
if (!dir.exists(save_path)) dir.create(save_path, recursive = TRUE)
datasets <- list()
for (i in seq_along(items_upper)) {
num <- as.integer(items_upper[[i]][1])
prefix <- items_upper[[i]][2]
cols <- names(df)[str_starts(names(df), prefix)]
pick <- c(if ("PublicID" %in% names(df)) "PublicID" else NULL,
setdiff(cols, "PublicID"))
single_df <- df %>% select(all_of(pick))
name <- sprintf("%d_%d_%s_single_dataset", i, num, prefix)
write_csv(single_df, file.path(save_path, paste0(name, ".csv")))
}
library(readr)
library(dplyr)
library(stringr)
here::i_am("R_version/Selecting_single_dataset.Rmd")
df <- read_csv(here::here('Data', 'Raw', 'nuMoM2b_Merged_Dataset.csv'),
show_col_types = FALSE)
DEMOGRAPHICS_COLS <- c(
"GAwks_screen","Age_at_V1","AgeCat_V1","CRace","Race","eRace","eHispanic",
"BMI","BMI_Cat","Education","GravCat","SmokeCat1","SmokeCat2","SmokeCat3",
"Ins_Govt","Ins_Mil","Ins_Comm","Ins_Pers","Ins_Othr","PctFedPoverty","poverty"
)
PREGNANCY_OUTCOMES_COLS <- c(
"DateofDelivery","pENDDATE_CA_INT","OUTCOME_avail","GA_avail","pOUTCOME_CA","pOUTCOME",
"PROM","SPONTANEOUS","SBTiming","GAwksCA","GAdysCA","GAwksA09","GAdysA09","GAwksEND",
"CA_GA","A09_GA","TYPE_CA","TYPE_CA_A09","PreGestDM","oDM","ChronHTN","PEgHTN",
"acog_PEgHTN","bw","SGA_alex","SGA_oken","SGA3pctl_oken"
)
items <- list(
c(3,  "a04"),
c(5,  "a09"),
c(25, "cla"),
c(27, "cma"),
c(28, "cmb"),
c(30, "cmd"),
c(31, "cme"),
c(35, "demographics"),
c(41, "pregnancy_outcomes"),
c(42, "s01"),
c(43, "s02"),
c(57, "v1a"),
c(58, "v1b"),
c(59, "v1c"),
c(60, "v1e"),
c(61, "v1f"),
c(65, "v1l"),
c(66, "v2a"),
c(70, "v3a"),
c(71, "v3b"),
c(72, "v3c"),
c(77, "v3l"),
c(78, "v4a"),
c(79, "vxx")
)
items_upper <- lapply(items, function(x) c(x[1], toupper(x[2])))
save_path <- here::here('R_version', 'outputs')
if (!dir.exists(save_path)) dir.create(save_path, recursive = TRUE)
datasets <- list()
for (i in seq_along(items_upper)) {
num <- as.integer(items_upper[[i]][1])
prefix <- items_upper[[i]][2]
# 3) minimal change: special handling for DEMOGRAPHICS / PREGNANCY_OUTCOMES
if (prefix == "DEMOGRAPHICS") {
cols <- intersect(DEMOGRAPHICS_COLS, names(df))
missing <- setdiff(DEMOGRAPHICS_COLS, names(df))
if (length(missing) > 0) message("[WARN] DEMOGRAPHICS missing: ", paste(missing, collapse = ", "))
} else if (prefix == "PREGNANCY_OUTCOMES") {
cols <- intersect(PREGNANCY_OUTCOMES_COLS, names(df))
missing <- setdiff(PREGNANCY_OUTCOMES_COLS, names(df))
if (length(missing) > 0) message("[WARN] PREGNANCY_OUTCOMES missing: ", paste(missing, collapse = ", "))
} else {
# case-insensitive startswith by uppercasing column names
cols <- names(df)[str_starts(toupper(names(df)), prefix)]
}
pick <- c(if ("PublicID" %in% names(df)) "PublicID" else NULL,
setdiff(cols, "PublicID"))
single_df <- df %>% select(all_of(pick))
name <- sprintf("%d_%d_%s_single_dataset", i, num, prefix)
write_csv(single_df, file.path(save_path, paste0(name, ".csv")))
}
